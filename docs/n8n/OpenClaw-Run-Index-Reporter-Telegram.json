{
  "name": "OpenClaw - Run Index Reporter (Telegram)",
  "nodes": [
    {
      "parameters": {
        "triggerTimes": [
          {
            "mode": "everyMinute"
          }
        ]
      },
      "id": "a0b6e4fd-6f2a-4b6f-a5d3-9a6d2fd4a7c1",
      "name": "æ¯åˆ†é˜è§¸ç™¼",
      "type": "n8n-nodes-base.cron",
      "typeVersion": 1,
      "position": [
        240,
        260
      ]
    },
    {
      "parameters": {
        "url": "={{($env.OPENCLAW_API_BASE || 'http://127.0.0.1:3011') + '/api/runs'}}",
        "method": "GET",
        "responseFormat": "json",
        "options": {
          "timeout": 30000
        },
        "headerParametersUi": {
          "parameter": [
            {
              "name": "X-API-Key",
              "value": "={{$env.OPENCLAW_API_KEY || ''}}"
            }
          ]
        }
      },
      "id": "6a3a1a5c-2d39-47b6-a2d7-3a6b2b1c5b36",
      "name": "æŠ“ Runsï¼ˆOpenClawï¼‰",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        460,
        260
      ]
    },
    {
      "parameters": {
        "functionCode": "const data = items[0].json;\nif (!Array.isArray(data)) {\n  return [];\n}\n\n// Keep a small local memory inside n8n (staticData) to avoid duplicate notifications.\nconst s = this.getWorkflowStaticData('global');\nif (!s.seenRunIds) s.seenRunIds = {};\n\nconst now = Date.now();\nconst maxAgeMs = Number($env.OPENCLAW_NOTIFY_MAX_AGE_MS || 6 * 60 * 60 * 1000); // default 6h\nconst maxKeep = Number($env.OPENCLAW_NOTIFY_MAX_KEEP || 5000);\n\n// prune old entries occasionally\nif (!s.lastPruneAt || (now - s.lastPruneAt) > 10 * 60 * 1000) {\n  const keys = Object.keys(s.seenRunIds);\n  if (keys.length > maxKeep) {\n    // Best-effort prune: keep newest by seenAt\n    keys.sort((a, b) => (s.seenRunIds[b] || 0) - (s.seenRunIds[a] || 0));\n    for (const k of keys.slice(maxKeep)) delete s.seenRunIds[k];\n  }\n  s.lastPruneAt = now;\n}\n\nconst onlySuccess = String($env.OPENCLAW_NOTIFY_ONLY_SUCCESS || 'true') !== 'false';\n\nconst out = [];\nfor (const r of data) {\n  if (!r || typeof r !== 'object') continue;\n  const id = String(r.id || '');\n  if (!id) continue;\n  if (s.seenRunIds[id]) continue;\n\n  const status = String(r.status || '');\n  if (onlySuccess && status !== 'success') continue;\n\n  const startedAt = r.startedAt ? Date.parse(r.startedAt) : NaN;\n  if (!Number.isNaN(startedAt) && (now - startedAt) > maxAgeMs) continue;\n\n  // Need runPath + taskId to be useful.\n  const runPath = String(r.runPath || '');\n  const taskId = String(r.taskId || '');\n  if (!runPath || !taskId) continue;\n\n  out.push({ json: { runId: id, taskId, taskName: String(r.taskName || ''), runPath, status } });\n}\n\n// Mark as seen immediately (idempotent) so retries don't spam.\nfor (const it of out) {\n  s.seenRunIds[it.json.runId] = now;\n}\n\nreturn out;"
      },
      "id": "f8c1b6db-1f4c-4c1d-9a1b-7d8a7c4c5b2e",
      "name": "éæ¿¾æ–°æˆåŠŸ Runï¼ˆå»é‡ï¼‰",
      "type": "n8n-nodes-base.function",
      "typeVersion": 2,
      "position": [
        700,
        260
      ]
    },
    {
      "parameters": {
        "batchSize": 1,
        "options": {}
      },
      "id": "7e9a7f02-1b2c-4b25-9d7e-88f25b8b7b8b",
      "name": "é€ç­†è™•ç†",
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [
        940,
        260
      ]
    },
    {
      "parameters": {
        "url": "={{($env.OPENCLAW_API_BASE || 'http://127.0.0.1:3011') + '/api/tasks/' + encodeURIComponent($json.taskId)}}",
        "method": "GET",
        "responseFormat": "json",
        "options": {
          "timeout": 30000
        },
        "headerParametersUi": {
          "parameter": [
            {
              "name": "X-API-Key",
              "value": "={{$env.OPENCLAW_API_KEY || ''}}"
            }
          ]
        }
      },
      "id": "f3d7bd6b-0d5b-4d10-9e1c-7c3e6c2c9b0a",
      "name": "æŠ“ Taskï¼ˆè£œæ¬„ä½ï¼‰",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        1180,
        260
      ]
    },
    {
      "parameters": {
        "functionCode": "const task = items[0].json;\nconst runId = $item(0).$node[\"é€ç­†è™•ç†\"].json.runId;\nconst runPath = $item(0).$node[\"é€ç­†è™•ç†\"].json.runPath;\nconst taskId = $item(0).$node[\"é€ç­†è™•ç†\"].json.taskId;\nconst taskName = $item(0).$node[\"é€ç­†è™•ç†\"].json.taskName || task?.name || '';\n\n// Build absolute filesystem path inside n8n docker container.\n// You must mount the repo into /workspace, e.g. -v \"/Users/.../openclawä»»å‹™é¢ç‰ˆè¨­è¨ˆ:/workspace\"\nconst rel = String(runPath || '').replace(/^\\/+/, '');\nconst resultPath = '/workspace/' + rel.replace(/\\/+$/, '/') + 'RESULT.md';\n\nreturn [{\n  json: {\n    taskId,\n    taskName,\n    runId,\n    runPath,\n    resultPath,\n    projectPath: task?.projectPath || '',\n    idempotencyKey: task?.idempotencyKey || '',\n  }\n}];"
      },
      "id": "8b8f0a6b-1b7a-4d8d-b8e3-6d9c7a3e5f21",
      "name": "çµ„åˆè·¯å¾‘èˆ‡ä¸Šä¸‹æ–‡",
      "type": "n8n-nodes-base.function",
      "typeVersion": 2,
      "position": [
        1420,
        260
      ]
    },
    {
      "parameters": {
        "filePath": "={{$json.resultPath}}"
      },
      "id": "5a2e8c3f-9b1e-4f8d-a2f3-8b9f1c2d3e4f",
      "name": "è®€ RESULT.md",
      "type": "n8n-nodes-base.readBinaryFile",
      "typeVersion": 1,
      "position": [
        1660,
        260
      ],
      "continueOnFail": true
    },
    {
      "parameters": {
        "functionCode": "function clamp(s, n) {\n  s = String(s || '').trim();\n  if (!s) return '';\n  return s.length <= n ? s : (s.slice(0, n).trimEnd() + 'â€¦');\n}\n\nconst runId = $json.runId;\nconst taskId = $json.taskId;\nconst taskName = $json.taskName;\nconst runPath = $json.runPath;\nconst resultPath = $json.resultPath;\n\nlet text = '';\ntry {\n  const b = items[0].binary?.data;\n  if (b?.data) {\n    text = Buffer.from(b.data, 'base64').toString('utf8');\n  }\n} catch (e) {\n  text = '';\n}\n\n// Extract summary block if present.\nlet summary = '';\nif (text) {\n  const m = text.match(/\\n##\\s*summary\\s*\\n([\\s\\S]*?)(\\n##\\s|$)/i);\n  if (m && m[1]) summary = m[1].trim();\n}\nif (!summary && text) {\n  const lines = text.split(/\\r?\\n/).map(l => l.trim()).filter(Boolean);\n  summary = lines.slice(0, 8).join('\\n');\n}\nsummary = clamp(summary, 800);\n\n// Extract key outline points from RESULT.md\nlet outlinePoints = [];\nif (text) {\n  // Look for h2/h3 headings as outline\n  const headings = text.match(/^#{2,3}\\s+.+$/gm);\n  if (headings && headings.length > 0) {\n    outlinePoints = headings\n      .map(h => h.replace(/^#+\\s*/, '').trim())\n      .filter(h => !/^(summary|next|todo)/i.test(h))\n      .slice(0, 6);\n  }\n}\n\n// Extract model info\nlet model = '';\nif (text) {\n  const mm = text.match(/(?:model|æ¨¡å‹)[ï¼š:]\\s*(.+)/i);\n  if (mm && mm[1]) model = mm[1].trim();\n}\n\n// Extract executor/agent info\nlet executor = '';\nif (text) {\n  const me = text.match(/(?:executor|åŸ·è¡Œè€…|agent)[ï¼š:]\\s*(.+)/i);\n  if (me && me[1]) executor = me[1].trim();\n}\n\n// Basic nextSteps heuristics.\nlet nextSteps = [];\nif (text) {\n  const m2 = text.match(/\\n##\\s*(next\\s*steps|nextSteps|todo|ä¸‹ä¸€æ­¥)\\s*\\n([\\s\\S]*?)(\\n##\\s|$)/i);\n  if (m2 && m2[2]) {\n    nextSteps = m2[2]\n      .split(/\\r?\\n/)\n      .map(l => l.replace(/^[-*\\d.\\s]+/, '').trim())\n      .filter(Boolean)\n      .slice(0, 6);\n  }\n}\nif (nextSteps.length === 0) {\n  nextSteps = [\n    'æŸ¥çœ‹ RESULT.md çš„å®Œæ•´å…§å®¹èˆ‡é©—æ”¶æ¸…å–®',\n    'ä¾ acceptanceCriteria é€é …äººå·¥é©—æ”¶',\n    'é©—æ”¶é€šéå¾Œå°‡ä»»å‹™ç‹€æ…‹æ”¹ç‚º doneï¼ˆæˆ–å»ºç«‹ä¸‹ä¸€å¼µä»»å‹™ï¼‰'\n  ];\n}\n\nconst evidenceLinks = [runPath.replace(/\\/+$/, '/') + 'RESULT.md'];\n\nreturn [{\n  json: {\n    taskId,\n    taskName,\n    runId,\n    runPath,\n    resultPath,\n    summary,\n    outlinePoints,\n    model,\n    executor,\n    nextSteps,\n    evidenceLinks\n  }\n}];"
      },
      "id": "1c2d3e4f-5a6b-4c7d-8e9f-0a1b2c3d4e5f",
      "name": "èƒå–ç´¢å¼•æ‘˜è¦ï¼ˆä¸è²¼å…¨æ–‡ï¼‰",
      "type": "n8n-nodes-base.function",
      "typeVersion": 2,
      "position": [
        1900,
        260
      ]
    },
    {
      "parameters": {
        "url": "={{($env.OPENCLAW_API_BASE || 'http://127.0.0.1:3011') + '/api/tasks/' + encodeURIComponent($json.taskId) + '/progress'}}",
        "method": "PATCH",
        "responseFormat": "json",
        "jsonParameters": true,
        "options": {
          "timeout": 30000
        },
        "headerParametersUi": {
          "parameter": [
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "X-API-Key",
              "value": "={{$env.OPENCLAW_API_KEY || ''}}"
            }
          ]
        },
        "bodyParametersJson": "={{JSON.stringify({\n  status: 'review',\n  runId: $json.runId,\n  summary: $json.summary,\n  nextSteps: $json.nextSteps,\n  evidenceLinks: $json.evidenceLinks\n})}}"
      },
      "id": "9b8a7c6d-5e4f-3a2b-1c0d-9e8f7a6b5c4d",
      "name": "å¯«å›ä»»å‹™å¡ï¼ˆprogressï¼‰",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        2140,
        260
      ],
      "continueOnFail": true
    },
    {
      "parameters": {
        "url": "={{'https://api.telegram.org/bot' + ($env.TELEGRAM_BOT_TOKEN || 'REPLACE_ME') + '/sendMessage'}}",
        "method": "POST",
        "responseFormat": "json",
        "jsonParameters": true,
        "options": {
          "timeout": 30000
        },
        "bodyParametersJson": "={{JSON.stringify({\n  chat_id: ($env.TELEGRAM_CHAT_ID || 'REPLACE_ME'),\n  parse_mode: 'HTML',\n  text: `ğŸ¤– <b>n8n ç³»çµ±äº‹ä»¶é€šçŸ¥</b>\\n\\n` +\n    `ğŸ“‹ ä»»å‹™: ${$json.taskName || '(æœªå‘½å)'}\\n` +\n    `âœ… ç‹€æ…‹: å®Œæˆ\\n` +\n    ($json.executor ? `ğŸ‘¤ åŸ·è¡Œè€…: ${$json.executor}\\n` : '') +\n    ($json.model ? `ğŸ§  å­ä»£ç†æ¨¡å‹: ${$json.model}\\n` : '') +\n    `â° æ™‚é–“: ${new Date().toLocaleString('zh-TW', {timeZone: 'Asia/Taipei'})}\\n` +\n    `\\nğŸ“ <b>é‡é»æ‘˜è¦:</b>\\n${$json.summary || '(ç„¡æ‘˜è¦)'}\\n` +\n    (($json.outlinePoints || []).length > 0 ? `\\nğŸ“‘ <b>å…§å®¹å¤§ç¶±:</b>\\n${$json.outlinePoints.map(p => 'â€¢ ' + p).join('\\n')}\\n` : '') +\n    `\\nğŸ”œ <b>ä¸‹ä¸€æ­¥:</b>\\n- ${($json.nextSteps || []).join('\\n- ')}\\n` +\n    `\\nğŸ”— è©³ç´°: ${($json.evidenceLinks || [])[0] || $json.runPath}`\n})}}"
      },
      "id": "0f1e2d3c-4b5a-6978-9f0e-1d2c3b4a5f6e",
      "name": "Telegram ç™¼ç´¢å¼•æ‘˜è¦",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        2380,
        260
      ],
      "continueOnFail": true
    },
    {
      "parameters": {},
      "id": "b3c2d1e0-f9a8-7654-3210-0f1e2d3c4b5a",
      "name": "ä¸‹ä¸€ç­†",
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        2620,
        260
      ]
    }
  ],
  "connections": {
    "æ¯åˆ†é˜è§¸ç™¼": {
      "main": [
        [
          {
            "node": "æŠ“ Runsï¼ˆOpenClawï¼‰",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "æŠ“ Runsï¼ˆOpenClawï¼‰": {
      "main": [
        [
          {
            "node": "éæ¿¾æ–°æˆåŠŸ Runï¼ˆå»é‡ï¼‰",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "éæ¿¾æ–°æˆåŠŸ Runï¼ˆå»é‡ï¼‰": {
      "main": [
        [
          {
            "node": "é€ç­†è™•ç†",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "é€ç­†è™•ç†": {
      "main": [
        [
          {
            "node": "æŠ“ Taskï¼ˆè£œæ¬„ä½ï¼‰",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "ä¸‹ä¸€ç­†",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "æŠ“ Taskï¼ˆè£œæ¬„ä½ï¼‰": {
      "main": [
        [
          {
            "node": "çµ„åˆè·¯å¾‘èˆ‡ä¸Šä¸‹æ–‡",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "çµ„åˆè·¯å¾‘èˆ‡ä¸Šä¸‹æ–‡": {
      "main": [
        [
          {
            "node": "è®€ RESULT.md",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "è®€ RESULT.md": {
      "main": [
        [
          {
            "node": "èƒå–ç´¢å¼•æ‘˜è¦ï¼ˆä¸è²¼å…¨æ–‡ï¼‰",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "èƒå–ç´¢å¼•æ‘˜è¦ï¼ˆä¸è²¼å…¨æ–‡ï¼‰": {
      "main": [
        [
          {
            "node": "å¯«å›ä»»å‹™å¡ï¼ˆprogressï¼‰",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "å¯«å›ä»»å‹™å¡ï¼ˆprogressï¼‰": {
      "main": [
        [
          {
            "node": "Telegram ç™¼ç´¢å¼•æ‘˜è¦",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Telegram ç™¼ç´¢å¼•æ‘˜è¦": {
      "main": [
        [
          {
            "node": "ä¸‹ä¸€ç­†",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ä¸‹ä¸€ç­†": {
      "main": [
        [
          {
            "node": "é€ç­†è™•ç†",
            "type": "main",
            "index": 1
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "00000000-0000-0000-0000-000000000000",
  "meta": {
    "templateCredsSetup": "No n8n credentials required; uses env vars + Telegram Bot API over HTTP."
  }
}

