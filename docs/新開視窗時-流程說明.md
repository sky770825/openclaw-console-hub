# 新開視窗時，會先有什麼樣的流程？

> **新開視窗** = 新的對話／新會話 = 新的 **session**（新的 sessionKey，對應一筆新的 session 檔，例如 `.jsonl`）。  
> 以下是一則訊息進來、要跑 Agent 時，**從頭開始的流程順序**（依 OpenClaw 實際程式邏輯整理）。

---

## 一、流程總覽（先後順序）

1. **決定 workspace**
   - 依 session / agent 設定決定 **workspace 目錄**（例如 `~/.openclaw/workspace` 或你設的 agent workspace）。
   - 若目錄不存在會先建立，並 **chdir 到該目錄**（之後讀檔、skills 都以此為根）。

2. **載入 Skills**
   - 從 workspace 載入 **skill 清單**（例如 `skills/notion/SKILL.md` 等）。
   - 若有 skillsSnapshot 就用快照，否則從 workspace 讀取。
   - 套用 **skill 的 env 覆寫**（例如 NOTION_API_KEY）。
   - 產生這輪要帶給模型的 **skillsPrompt**（skill 說明摘要）。

3. **決定 bootstrap 模式（light vs full）**
   - 用 **本輪使用者訊息** 做 **isCasualChat(prompt)** 判斷：
     - **一般閒聊**（你好、嗨、ok…）→ **light**：只帶 IDENTITY + 精簡 USER。
     - **有任務／記憶關鍵字**（幫我、記下來、查一下…）→ **full**：帶完整工作區檔案。
   - 若設定關掉 `casualChatLightBootstrap`，則一律 **full**。

4. **載入 bootstrap 檔案（工作區固定檔）**
   - 依上一步的 **bootstrapMode** 呼叫 **resolveBootstrapContextForRun**：
     - **full**：從 workspace 讀取並組進 context：
       - AGENTS.md、SOUL.md、TOOLS.md、IDENTITY.md、USER.md、HEARTBEAT.md、BOOTSTRAP.md、**MEMORY.md**（及 memory/*.md 若有）。
     - **light**：只讀 **IDENTITY.md** + **USER.md**（前 200 字），其餘都不帶。
   - 若有 **agent:bootstrap** 勾子，會在這裡改寫要載入的檔案清單。
   - 讀完後轉成 **contextFiles**（要放進 system prompt 的檔案內容）。

5. **組裝工具與系統提示**
   - **createOpenClawCodingTools**：依 channel、workspace、config 建立本輪可用的工具（含 memory_search、edit、Notion 相關等）。
   - **buildEmbeddedSystemPrompt**：把 **contextFiles**（bootstrap 內容）、**skillsPrompt**、runtime 資訊、工具說明等組成 **系統提示**。

6. **處理 session 檔（新視窗 = 新檔）**
   - **sessionFile** 路徑由 sessionKey / sessionId 決定；**新開視窗** = 新的 sessionKey → 對應一個**新的 session 檔**（或尚未存在的檔）。
   - **acquireSessionWriteLock(sessionFile)**：取得寫入鎖。
   - **repairSessionFileIfNeeded**：若檔損壞會嘗試修復。
   - **prewarmSessionFile**：預熱／確保檔存在。
   - **SessionManager.open(sessionFile)**：開啟或建立該 session 檔（**新視窗時通常是新檔，裡面還沒有對話**）。
   - **prepareSessionManagerForRun**：確保第一則 user 訊息之後會正確被寫入。

7. **建立 Agent Session 並注入系統提示**
   - **createAgentSession**：依 SessionManager（即該 session 檔的內容）建立執行用的 session；**新視窗時 transcript 是空的**，只有之後 append 的訊息。
   - **applySystemPromptOverrideToSession**：把上面組好的**完整系統提示**（含 bootstrap、skills、工具說明）設進 session。

8. **本輪訊息與執行**
   - 把**本輪使用者訊息**（與若有從 channel 帶來的歷史）交給 agent。
   - Agent 依系統提示 + 工具 + 對話歷史做 **stream 回覆**；過程中可呼叫 **memory_search**、**edit**、Notion API 等。
   - 回覆與 tool 結果會寫回 **session 檔**（transcript），供之後同一視窗的下一輪使用。

---

## 二、新開視窗時特別要記的幾點

| 項目 | 說明 |
|------|------|
| **Workspace** | 和舊視窗**同一個** workspace 目錄（除非你為不同 agent/session 設了不同目錄）。所以 **MEMORY.md、USER.md、AGENTS.md** 等是共用的。 |
| **Session 檔** | **新**的，所以 **沒有舊視窗的對話紀錄**；只有本視窗之後的對話會寫進這支檔。 |
| **Bootstrap** | **每輪**都會重新依「本輪訊息」決定 light/full，再從 workspace **重新讀** MEMORY.md、AGENTS 等。所以 **MEMORY.md 裡已寫好的內容，新視窗一開就會被讀到**（full 時）。 |
| **記憶** | 跨視窗的記憶靠 **MEMORY.md、memory/*.md**（與 optional Notion）；新視窗不會帶舊視窗的 transcript，但會帶 **同一份 MEMORY** 與 skills。 |

---

## 三、一句話總結

**新開視窗時**：先定 workspace → 載入 skills → 用**本輪第一則訊息**決定 light/full → 從 workspace **載入對應的 bootstrap 檔**（full 時含 MEMORY.md）→ 開**新的** session 檔 → 把系統提示（含 bootstrap 內容）設進 session → 再處理你這則訊息並回覆。  
所以「前面」的流程就是：**workspace → skills → bootstrap 模式 → 讀工作區檔案 → 開 session 檔 → 注入系統提示**，之後才輪到你的訊息與模型回覆。

---

## 相關文件

- [新視窗或新訊息維持之前記憶-實施方式](./新視窗或新訊息維持之前記憶-實施方式.md)
- [記憶與對話-一般聊天輕量模式設計](./記憶與對話-一般聊天輕量模式設計.md)
- [動態載入與按需記憶-可行做法](./動態載入與按需記憶-可行做法.md)
