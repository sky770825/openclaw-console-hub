# 新視窗或新訊息維持之前記憶 — 實施方式

你希望**開新視窗或新會話時，仍能維持「之前說過的」記憶**。OpenClaw 的做法是：**把要長期記住的內容寫進 workspace 的記憶檔**，新 session 會重新載入這些檔並用 **memory_search** 查詢，所以「記憶」可以跨視窗、跨會話保留。

---

## 一、為什麼新視窗會「失憶」？

- **新視窗 / 新會話** = 新的 **session**（新的 transcript 檔）。
- 舊 session 的**對話紀錄**只存在舊的 `.jsonl` 裡，新 session **不會**自動帶入那段對話。
- 所以若沒有把重要內容寫到「會一直被讀取」的地方，新視窗就等於從頭開始。

---

## 二、什麼會「跨 session」保留？

| 內容 | 是否跨 session | 說明 |
|------|----------------|------|
| **MEMORY.md** | ✅ 會 | 在 workspace，每次 session 都會被注入到系統提示或可被 memory_search 查。 |
| **memory/*.md**（如 memory/2026-02-08.md） | ✅ 會 | 同上，在 workspace，QMD／builtin 會索引，memory_search 查得到。 |
| **USER.md、SOUL.md、AGENTS.md 等** | ✅ 會 | 在 workspace，每次都會注入，等同「固定人設／設定」的記憶。 |
| **舊 session 的對話 transcript** | ❌ 預設不會 | 新 session 不會載入舊的 .jsonl；除非啟用「session 匯出＋索引」（見下方）。 |

所以：**只要把「之前說過的、希望之後還記得」的內容寫進 MEMORY.md 或 memory/*.md（或固定放在 USER.md 等），新視窗／新訊息就能維持這些記憶。**

---

## 三、怎麼實施（具體步驟）

### 1. 維持現有記憶檔結構（你已有）

你的 workspace 已有：

- **MEMORY.md**：長期記憶（決定、偏好、待辦、重要摘要）。
- **memory/YYYY-MM-DD.md**：依日期的筆記（例如 pre-compaction flush 或手動寫入）。

不必改檔名或路徑，保持這樣即可。新 session 會讀同一個 workspace，所以這些檔的內容就是「跨 session 的記憶」。

### 2. 讓 Agent 養成「寫入記憶」的習慣

有兩種方式（可並用）：

**方式 A：你口頭提醒**

- 在重要結論、待辦、偏好時，結尾加一句，例如：  
  **「把這個記到 MEMORY」**、**「寫進今天的 memory 筆記」**。  
- Agent 有 **edit / write** 工具，可以寫入 `MEMORY.md` 或 `memory/2026-02-08.md`；系統提示裡也有 Memory Recall，會依任務用 **memory_search**，若你明確說「記下來」，通常會寫檔。

**方式 B：在 USER.md 或 AGENTS.md 寫死規則（推薦）**

在 `~/.openclaw/workspace/USER.md`（或 AGENTS.md）裡加一段，例如：

```markdown
## 記憶與新會話
- 重要結論、待辦、偏好、約定，請寫入 MEMORY.md 或 memory/YYYY-MM-DD.md。
- 這樣我開新視窗或新會話時，你仍可以從記憶裡讀到這些內容。
```

之後每個新 session 都會載入 USER.md，Agent 就會依這條規則在適當時候寫入記憶。

### 3. 善用 Pre-compaction memory flush（預設已開）

- OpenClaw 的 **pre-compaction memory flush** 預設是開啟的：在對話快壓縮前，會先跑一輪「把重要內容寫進 memory」的 silent turn。
- 也就是說，**同一 session 內**對話變很長、觸發壓縮前，會先盡量把重點寫進 `memory/*.md`，所以即使同一視窗後來壓縮了，這些重點已經在記憶檔裡，**新視窗**也能透過 MEMORY / memory/*.md 看到。

你不需要改設定，只要保持 compaction 與 memory flush 預設即可。

### 4. 確保 memory 搜尋可用（新 session 才能「查」到舊記憶）

- **memory_search** 會查：MEMORY.md + memory/*.md（以及若有的「session 匯出」）。
- 要讓新 session 能「查」到這些，需要 **memory backend** 有啟用（QMD 或 builtin 皆可）。

在 `~/.openclaw/openclaw.json` 確認有 **memory** 區塊，例如：

```json
"memory": {
  "backend": "qmd",
  "qmd": {
    "command": "qmd",
    "includeDefaultMemory": true
  }
}
```

若沒裝 QMD，可改用 `"backend": "builtin"`（或省略，預設即 builtin）。這樣新視窗裡 Agent 一樣可以用 **memory_search** 查 MEMORY.md + memory/*.md，把「之前說過的」拉進當前回覆。

### 5. 可選：連「舊對話內容」都可被搜到（QMD session 匯出）

若希望**不只 MEMORY.md / memory/*.md，連過去某次對話的內容**都能在新視窗被搜到，可以啟用 QMD 的 **session 匯出與索引**（若你的版本支援）：

在 `memory.qmd` 裡加上：

```json
"memory": {
  "backend": "qmd",
  "qmd": {
    "command": "qmd",
    "includeDefaultMemory": true,
    "sessions": {
      "enabled": true,
      "exportDir": "~/.openclaw/agents/main/sessions",
      "retentionDays": 30
    }
  }
}
```

（實際欄位與路徑以官方文件為準；若無 `sessions` 或 `exportDir`，則只靠 MEMORY.md + memory/*.md 也足夠維持「之前說過的」重點記憶。）

---

## 四、流程整理

1. **同一視窗內**：對話中你或 Agent 把重點寫進 **MEMORY.md** 或 **memory/YYYY-MM-DD.md**；或依賴 pre-compaction flush 自動寫入。
2. **開新視窗 / 新會話**：新 session 載入同一個 workspace → 會再次注入 **MEMORY.md**、**USER.md** 等，並可用 **memory_search** 查 MEMORY + memory/*.md（與若有設定的 session 匯出）。
3. **新訊息裡問「之前說過的事」**：Agent 會依系統提示先做 **memory_search**，把相關片段拉進來再回答，所以能「維持之前說過的記憶」。

---

## 五、建議你先做的一步

**在 `~/.openclaw/workspace/USER.md` 加一段「記憶與新會話」說明**（如上方式 B），並口頭提醒一兩次「重要的事記到 MEMORY」。之後開新視窗或新訊息，就會在「上下文完整」與「跨 session 記憶」之間取得平衡；若再搭配 QMD（或 builtin）與可選的 session 匯出，就能盡量讓之前說過的內容在新會話裡仍被保留與查詢。
